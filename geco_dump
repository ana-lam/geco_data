#!/bin/bash

# a script for dumping to text a timeseries for a given channel
# over a given time range from the highest speed storage medium
# Stefan Countryman 4/2/2016

set -o errexit
set -o nounset
set -o noclobber
# print everything before executing
# set -o xtrace

usage() {
    cat <<USAGE
USAGE: geco_dump [ OPTIONS ] -s start_time -e end_time [ -l channel_list | -c channel_name [ ... ] ] channel_names ...

ARGUMENTS:

    All arguments are interpreted as channel names. This makes it easy to use
    a pipe and xargs to choose channel names. Other options must be set
    using

OPTIONS:

    -s start_time         is in the form Sep 01 00:00:00 GMT 2015. REQUIRED.

    -e end_time           is in the same form as start_time. REQUIRED.

    -c channel_name       is the full channel name. Can be used multiple times
			  to specify multiple channels. At least one channel is
                          REQUIRED, either using the -c flag explicitly, listing
                          channels as arguments, or specifying a predefined
                          list of channels with the -l flag (all three can be
                          combined).

    -l channel_list       is a keyword specifying one of the following preset
                          lists of channels:

                          slow   -- slow channels

    -p output_directory   defaults to ~/. Timeseries text files will be saved
                          to output_directory/channel_name.

    -P                    do not start a new dump, but check the progress of
                          an ongoing dump with the given parameters.

    -T                    start a new dump, but instead of saving the output
                          of framecpp_dump_channel to text files (complete
                          with text headers), only output the concatenated
                          timeseries as strings (with no header information
			  or diagnostic messages). Useful for piping timeseries
                          into other programs. This option can only be used
                          with a single channel specified.

    -R                    dump a timeseries string from files previously
                          output by geco_dump. Like the -T flag, but will read
                          from text files previously generated by geco_dump,
                          significantly increasing speed. If BOTH -R and -T
                          are specified, geco_dump will try to read from
                          previously generated text files before falling back
                          to reading from GW frame files.

    -h                    shows this message.

USAGE
}

# get the path to a frame file for observatory H or L for some time
get_frame_file_path () {
    observatory_letter=${1}
    current_time=${2}
    gw_data_find -o ${observatory_letter} \
                 -t ${observatory_letter}1_R \
                 -s ${current_time} \
                 -e ${current_time} \
                 -u file \
        | sed 's/[^:^\/]*:\/\/[^\/]*//'
}

get_outdir () {
    outdir_pre="${1}"
    channel_name="${2}"
    # default output directory is ~/channel_name; else is outdir_pre/channel_name
    if [ "$outdir_pre" == "" ]; then
        printf "$HOME/$(printf "${channel_name}" | tr ':' '_')"
    else
        printf "${outdir_pre}/$(printf "${channel_name}" | tr ':' '_')"
    fi
}

# function for dumping channels (inspired by original geco_dump_channel)
# dump dump_start_time dump_end_time outdir channel_name
dump () {
    dump_start_time="${1}"
    dump_end_time="${2}"
    outdir="${3}"
    channel_name="${4}"
    # make it possible to print purely to a timeseries string. log messages
    # are printed only to stderr.
    print_timeseries_string=${5:-false}
    read_from_dumped_files=${6:-false}
    # get data for each time
    current_time="${dump_start_time}"
    if ! [ -e "${outdir}" ]; then
        mkdir -p "${outdir}"
    fi
    # first letter of channel specifies observatory; needed by gw_data_find
    observatory_letter="$(echo ${channel_name} | head -c 1)"
    while [ "${current_time}" -lt "${dump_end_time}" ]; do
        # create a descriptive path name where this should be saved
        outpath="${outdir}/${current_time}".dat
        # see if -T flag is activated, i.e. we are printing raw timeseries
        if ${read_from_dumped_files}; then
            if [ -e "${outpath}" ]; then
                # make sure the channel is correct
                sed -n "2 {/${channel_name}/!q1};1,6d;s/^Data: //;s/ //g;p" ${outpath}
            else
                echo No data file found for ${current_time}, exiting. >&2
                exit 1
            fi
        elif ${print_timeseries_string}; then
            inpath=$(get_frame_file_path ${observatory_letter} ${current_time})
            if [ "${inpath}" == "" ]; then
                echo No frame file found for ${current_time}, exiting. >&2
                exit 1
            else
                framecpp_dump_channel --channel "${channel_name}" \
                                      "${inpath}" \
                    | sed '1,6d' \
                    | sed 's/^Data: //' \
                    | tr -d ' '
            fi
        else
            inpath=$(get_frame_file_path ${observatory_letter} ${current_time})
            # skip the file if it already exists
            if ! [ -e "${outpath}" ]; then
                # get the file path for this time; if missing, mark it so.
                if [ "${inpath}" == "" ]; then
                    touch "${outpath}".missing
                else
                    framecpp_dump_channel --channel "${channel_name}" \
                                          "${inpath}" > "${outpath}"
                    if [ -e "${outpath}".missing ]; then
                        echo Found missing file ${outpath}.
                        rm -v ${outpath}.missing
                    fi
                fi
            fi
        fi

        # move on to the next time
        let 'current_time+=64'
    done
}

# lists of timediff channels from channels.py file:
# slow_channels=`cat dev/data/channels.py | sed -n '2,13p' | sed -ne 's/.*'"'"'\(.*\)'"'"'$/\1/p'`
slow_channels=(
    "H1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_2"
    "H1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "H1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "L1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_2"
    "L1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "L1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3")

# get options
outdir_pre=""
start_time=""
end_time=""
check_dump_progress=false
read_from_dumped_files=false
print_timeseries_string=false
unset channel_names
while getopts ":p:s:e:c:l:PTRh" opt; do
    case ${opt} in
        p)  outdir_pre="${OPTARG}";;
        s)  start_time="${OPTARG}";;
        e)  end_time="${OPTARG}";;
        c)  channel_names+=("${OPTARG}");;
        l)
            case "${OPTARG}" in
                slow) channel_names+=${slow_channels[*]};;
            esac
            ;;
        P)  check_dump_progress=true;;
        T)  print_timeseries_string=true;;
        R)  read_from_dumped_files=true;;
        h)  usage && exit;;
        :)
            echo "Option -${OPTARG} requires an argument." >&2
            exit 1
            ;;
        \?)
            echo "Invalid option: -${OPTARG}" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

# any trailing arguments are interpreted as channels
while (( "$#" )); do
    channel_names+=("${1}")
    shift
done

# there should be no non-flag arguments
if ! [ "$#" == 0 ]; then
    echo "Expected only flag arguments; got $# non-flag arguments." >&2
    usage
    exit 1
elif [ "${start_time}" == "" ]; then
    echo "Error: Must provide start time with -s flag." >&2
    usage
    exit 1
elif [ "${end_time}" == "" ]; then
    echo "Error: Must provide end time with -e flag." >&2
    usage
    exit 1
elif [ "${#channel_names[*]}" == "0" ]; then
    echo "Error: Must provide at least one channel name with -c flag." >&2
    usage
    exit 1
elif ${print_timeseries_string} || ${read_from_dumped_files} && ${check_dump_progress}; then
    echo "Error: Cannot specify -P and -T or -P and -R flags at once." >&2
    usage
    exit 1
elif ${print_timeseries_string} || ${read_from_dumped_files} && ! [ "${#channel_names[*]}" == "1" ]; then
    echo "Error: Must specify exactly one channel name with -T or -R flag." >&2
    usage
    exit 1
fi

gps_start_time=$(lalapps_tconvert ${start_time})
gps_end_time=$(lalapps_tconvert ${end_time})
if ${check_dump_progress}; then
    # total number of frame files to be processed in this time range
    num_frame_files=$(dc -e "${gps_end_time} 64/${gps_start_time} 64/-1+p")
    while true; do
        clear
        echo Start time: $(lalapps_tconvert -d ${start_time})
        echo End time: $(lalapps_tconvert -d ${end_time})
        echo GPS start time: ${gps_start_time}
        echo GPS end time: ${gps_end_time}
        echo Files to process: ${num_frame_files}
        echo NOTE: If data cannot be found, files will be skipped, causing
        echo progress to seemingly hang at around 100%.
        printf 'CURRENT TIME: '
        date
        printf 'SIZE MODIFIED         CHANNEL\n'
        for channel_name in ${channel_names[*]}; do
            outdir="$(get_outdir "${outdir_pre}" "${channel_name}")"
            usg=$(du -h --time --max-depth=0 "${outdir}")
            cnt=$(ls "${outdir}" | wc -l)
            pct=$(dc -e "${cnt} 100*${num_frame_files}/p")
            echo ${usg} ${cnt}/${num_frame_files} \(${pct}\%\)
        done
        # sleep for 5 minutes before recomputing, or accept input
        read -n 1 -s -t 500 -p 'press [q] to quit or [r] to refresh.' cmnd
        case "${cmnd}" in
            q) echo && exit;;
            r) continue;;
        esac
    done
else
    # dump each channel
    dump_start_time=$(dc -e "${gps_start_time} 64/64*p")
    dump_end_time=$(dc -e "${gps_end_time} 64/64*64+p")
    # fork a process for each channel dump and print output to a log file
    for channel_name in ${channel_names[*]}; do
        outdir="$(get_outdir "${outdir_pre}" "${channel_name}")"
        if ${print_timeseries_string}; then
            dump "${dump_start_time}" "${dump_end_time}" \
                 "${outdir}" "${channel_name}" true false \
                | tr '\n' ','
        elif ${read_from_dumped_files}; then
            dump "${dump_start_time}" "${dump_end_time}" \
                 "${outdir}" "${channel_name}" false true \
                | tr '\n' ','
        else
            echo Forking for ${channel_name}
            logfile="${outdir}.log"
            dump "${dump_start_time}" "${dump_end_time}" \
                 "${outdir}" "${channel_name}" \
                >> "${logfile}" &
        fi
    done
fi
