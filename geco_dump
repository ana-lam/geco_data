#!/bin/bash

# a script for dumping to text a timeseries for a given channel
# over a given time range from the highest speed storage medium
# Stefan Countryman 4/2/2016

set -o errexit
set -o nounset
set -o noclobber
# print everything before executing
# set -o xtrace

usage() {
    cat <<USAGE
USAGE: geco_dump [ OPTIONS ] -s start_time -e end_time [ -l channel_list | -c channel_name [ ... ] ] channel_names ...

ARGUMENTS:

    All arguments are interpreted as channel names. This makes it easy to use
    a pipe and xargs to choose channel names. Other options must be set
    using

OPTIONS:

    -s start_time         is in the form Sep 01 00:00:00 GMT 2015. REQUIRED.

    -e end_time           is in the same form as start_time. Note that the
                          final second is NOT included when used with the
                          -T or -R options below. When used to dump data to
                          file, the times are rounded up and down so that all
                          frame files with the included times are dumped.
                          REQUIRED.

    -c channel_name       is the full channel name. Can be used multiple times
			  to specify multiple channels. At least one channel is
                          REQUIRED, either using the -c flag explicitly, listing
                          channels as arguments, or specifying a predefined
                          list of channels with the -l flag (all three can be
                          combined).

    -l channel_list       is a keyword specifying one of the following preset
                          lists of channels:

                          slow   -- slow channels

    -p output_directory   defaults to ~/. Timeseries text files will be saved
                          to output_directory/channel_name.

    -P                    do not start a new dump, but check the progress of
                          an ongoing dump with the given parameters.

    -T                    start a new dump, but instead of saving the output
                          of framecpp_dump_channel to text files (complete
                          with text headers), only output the concatenated
                          timeseries as strings (with no header information
			  or diagnostic messages). Useful for piping timeseries
                          into other programs. This option can only be used
                          with a single channel specified. The values returned
                          will each appear on a new line.

    -R                    dump a timeseries string from files previously
                          output by geco_dump. Like the -T flag, but will read
                          from text files previously generated by geco_dump,
                          significantly increasing speed. The values returned
                          will each appear on a new line.

    -RT                   If BOTH -R and -T
                          are specified, geco_dump will try to read from
                          previously generated text files before falling back
                          to reading from GW frame files.

    -h                    shows this message.

USAGE
}

# get the path to a frame file for observatory H or L for some time
get_frame_file_path () {
    observatory_letter=${1}
    current_time=${2}
    gw_data_find -o ${observatory_letter} \
                 -t ${observatory_letter}1_R \
                 -s ${current_time} \
                 -e ${current_time} \
                 -u file \
        | sed 's/[^:^\/]*:\/\/[^\/]*//'
}

# take comma-delimited vals from stdin, delete the first $1 of them
cut_terms_from_start () {
    awk -F',' '{
        for(i='$1'+1;i<NF;i++){
            printf "%s,", $i
        };
        i=NF;
        printf "%s", $i;
        printf "\n"
    }'
}

# take comma-delimited vals from stdin, delete the last $1 of them
cut_terms_from_end () {
    awk -F',' '{
        for(i=1;i<NF-'$1';i++){
            printf "%s,", $i
        };
        i=NF-'$1';
        printf "%s", $i;
        printf "\n"
    }'
}

# check if text file corresponds to correct channel, then dump timeseries
# with each value on a new line
check_and_dump () {
    sed -n "
        2{/${channel_name}/!q1}
        7s/[Dat: ]//g
        s/,/"$'\\\n/gp
    '
}

# figure out how many lines to cut from the start and end
cut_lines () {
    bitrate=${1}
    current_time=${2}
    gps_start_time="${3}"
    gps_end_time="${4}"
    dump_start_time=$(dc -e "${gps_start_time} 64/64*p")
    dump_end_time=$(dc -e "${gps_end_time} 64/64*64+p")
    del_at_start=""                 # delete nothing at start by default
    del_at_end=""                   # delete nothing at end by default
    if [ "${current_time}" -eq "${dump_start_time}" ]; then
        del_at_start="1,$(( ( gps_start_time - current_time ) * bitrate ))d;" 
    fi
    if [ "${current_time}" -eq $(( dump_end_time - 64 )) ]; then
        del_at_end="$(( ( gps_end_time - current_time ) * bitrate + 1 )),"'$d;'
    fi
    sed "${del_at_start}${del_at_end}"
}
    
    

get_outdir () {
    outdir_pre="${1}"
    channel_name="${2}"
    # default output directory is ~/channel_name; else is outdir_pre/channel_name
    if [ "$outdir_pre" == "" ]; then
        printf "$HOME/$(printf "${channel_name}" | tr ':' '_')"
    else
        printf "${outdir_pre}/$(printf "${channel_name}" | tr ':' '_')"
    fi
}

# function for dumping channels (inspired by original geco_dump_channel)
# dump dump_start_time dump_end_time outdir channel_name
dump () {
    gps_start_time="${1}"
    gps_end_time="${2}"
    outdir="${3}"
    channel_name="${4}"
    # make it possible to print purely to a timeseries string. log messages
    # are printed only to stderr.
    print_timeseries_string=${5:-false}
    read_from_dumped_files=${6:-false}
    # find first and post-ultimate frame file times
    dump_start_time=$(dc -e "${gps_start_time} 64/64*p")
    dump_end_time=$(dc -e "${gps_end_time} 64/64*64+p")
    # get data for each time
    current_time="${dump_start_time}"
    if ! ${print_timeseries_string} && ! ${read_from_dumped_files} \
            && ! [ -e "${outdir}" ]; then
        mkdir -p "${outdir}"
    fi
    # first letter of channel specifies observatory; needed by gw_data_find
    observatory_letter="$(echo ${channel_name} | head -c 1)"
    # if dumping timeseries, get the bit rate from the first dumped second;
    # this appears on the fifth line of the output of framecpp_dump_channel
    if ${read_from_dumped_files}; then
        outpath="${outdir}/${current_time}".dat
        bitrate=$(( $(sed '5s/[NDat: ]//g;5q;d' ${outpath}) / 64 ))
    elif ${print_timeseries_string}; then
        inpath=$(get_frame_file_path ${observatory_letter} ${current_time})
        buffer=$(mktemp)
        # the >| symbol overrides noclobber for this one operation
        framecpp_dump_channel --channel "${channel_name}" \
                              "${inpath}" >| "${buffer}"
        bitrate=$(( $(sed '5s/[NDat: ]//g;5q;d' "${buffer}") / 64 ))
    fi
    while [ "${current_time}" -lt "${dump_end_time}" ]; do
        # create a descriptive path name where this should be saved
        outpath="${outdir}/${current_time}".dat
        # see if -T flag is activated, i.e. we are printing raw timeseries
        if ${read_from_dumped_files}; then
            if [ -e "${outpath}" ]; then
                # make sure the channel is correct and cut unwanted values
                # from start and end
                check_and_dump < ${outpath} \
                    | cut_lines ${bitrate} ${current_time} \
                                ${gps_start_time} ${gps_end_time}
            else
                echo No data file found for ${current_time}, exiting. >&2
                exit 1
            fi
        elif ${print_timeseries_string}; then
            inpath=$(get_frame_file_path ${observatory_letter} ${current_time})
            if [ "${inpath}" == "" ]; then
                echo No frame file found for ${current_time}, exiting. >&2
                exit 1
            elif [ "${current_time}" -eq "${dump_start_time}" ]; then
                # don't bother dumping the first file twice
                cat "${buffer}" \
                    | check_and_dump \
                    | cut_lines ${bitrate} ${current_time} \
                                ${gps_start_time} ${gps_end_time}
            else
                framecpp_dump_channel --channel "${channel_name}" \
                                      "${inpath}" \
                    | check_and_dump \
                    | cut_lines ${bitrate} ${current_time} \
                                ${gps_start_time} ${gps_end_time}
            fi
        else
            inpath=$(get_frame_file_path ${observatory_letter} ${current_time})
            # skip the file if it already exists
            if ! [ -e "${outpath}" ]; then
                # get the file path for this time; if missing, mark it so.
                if [ "${inpath}" == "" ]; then
                    touch "${outpath}".missing
                else
                    framecpp_dump_channel --channel "${channel_name}" \
                                          "${inpath}" > "${outpath}"
                    if [ -e "${outpath}".missing ]; then
                        echo Found missing file ${outpath}.
                        rm -v ${outpath}.missing
                    fi
                fi
            fi
        fi

        # move on to the next time
        let 'current_time+=64'
    done
}

# lists of timediff channels from channels.py file:
# slow_channels=`cat dev/data/channels.py | sed -n '2,13p' | sed -ne 's/.*'"'"'\(.*\)'"'"'$/\1/p'`
slow_channels=(
    "H1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_2"
    "H1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "H1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "L1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_2"
    "L1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "L1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3")

# get options
outdir_pre=""
start_time=""
end_time=""
check_dump_progress=false
read_from_dumped_files=false
print_timeseries_string=false
unset channel_names
while getopts ":p:s:e:c:l:PTRh" opt; do
    case ${opt} in
        p)  outdir_pre="${OPTARG}";;
        s)  start_time="${OPTARG}";;
        e)  end_time="${OPTARG}";;
        c)  channel_names+=("${OPTARG}");;
        l)
            case "${OPTARG}" in
                slow) channel_names+=( ${slow_channels[@]} );;
            esac
            ;;
        P)  check_dump_progress=true;;
        T)  print_timeseries_string=true;;
        R)  read_from_dumped_files=true;;
        h)  usage && exit;;
        :)
            echo "Option -${OPTARG} requires an argument." >&2
            exit 1
            ;;
        \?)
            echo "Invalid option: -${OPTARG}" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

# any trailing arguments are interpreted as channels
while (( "$#" )); do
    channel_names+=("${1}")
    shift
done

# there should be no non-flag arguments
if ! [ "$#" == 0 ]; then
    echo "Expected only flag arguments; got $# non-flag arguments." >&2
    usage
    exit 1
elif [ "${start_time}" == "" ]; then
    echo "Error: Must provide start time with -s flag." >&2
    usage
    exit 1
elif [ "${end_time}" == "" ]; then
    echo "Error: Must provide end time with -e flag." >&2
    usage
    exit 1
elif [ "${#channel_names[*]}" == "0" ]; then
    echo "Error: Must provide at least one channel name with -c flag." >&2
    usage
    exit 1
elif ${print_timeseries_string} || ${read_from_dumped_files} && ${check_dump_progress}; then
    echo "Error: Cannot specify -P and -T or -P and -R flags at once." >&2
    usage
    exit 1
elif ${print_timeseries_string} || ${read_from_dumped_files} && ! [ "${#channel_names[*]}" == "1" ]; then
    echo "Error: Must specify exactly one channel name with -T or -R flag." >&2
    usage
    exit 1
fi

gps_start_time=$(lalapps_tconvert ${start_time})
gps_end_time=$(lalapps_tconvert ${end_time})
if ${check_dump_progress}; then
    # total number of frame files to be processed in this time range
    num_frame_files=$(dc -e "${gps_end_time} 64/${gps_start_time} 64/-1+p")
    while true; do
        clear
        echo Start time: $(lalapps_tconvert -d ${start_time})
        echo End time: $(lalapps_tconvert -d ${end_time})
        echo GPS start time: ${gps_start_time}
        echo GPS end time: ${gps_end_time}
        echo Files to process: ${num_frame_files}
        echo NOTE: If data cannot be found, files will be skipped, causing
        echo progress to seemingly hang at around 100%.
        printf 'CURRENT TIME: '
        date
        printf 'SIZE MODIFIED         PATH\n'
        for channel_name in ${channel_names[*]}; do
            outdir="$(get_outdir "${outdir_pre}" "${channel_name}")"
            usg=$(du -h --time --max-depth=0 "${outdir}")
            cnt=$(ls "${outdir}" | wc -l)
            pct=$(dc -e "${cnt} 100*${num_frame_files}/p")
            echo ${usg} ${cnt}/${num_frame_files} \(${pct}\%\)
        done
        # sleep for 5 minutes before recomputing, or accept input
        read -n 1 -s -t 500 -p 'press [q] to quit or [r] to refresh.' cmnd
        case "${cmnd}" in
            q) echo && exit;;
            r) continue;;
        esac
    done
else
    # fork a process for each channel dump and print output to a log file
    for channel_name in ${channel_names[*]}; do
        outdir="$(get_outdir "${outdir_pre}" "${channel_name}")"
        if ${print_timeseries_string} || ${read_from_dumped_files}; then
            dump "${gps_start_time}" "${gps_end_time}" \
                 "${outdir}" "${channel_name}" \
                 ${print_timeseries_string} ${read_from_dumped_files}
        else
            echo Forking for ${channel_name}
            logfile="${outdir}.log"
            dump "${gps_start_time}" "${gps_end_time}" \
                 "${outdir}" "${channel_name}" \
                >> "${logfile}" &
        fi
    done
fi
