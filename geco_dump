#!/bin/bash

# a script for dumping to text a timeseries for a given channel
# over a given time range from the highest speed storage medium
# Stefan Countryman 4/2/2016

set -o errexit
set -o nounset
set -o noclobber
# print everything before executing
# set -o xtrace

usage() {
    cat <<USAGE
USAGE: geco_dump -s start_time -e end_time [ -l channel_list | -c channel_name [ ... ] ] [ OPTIONS ]

OPTIONS:

    -s start_time         is in the form Sep 01 00:00:00 GMT 2015. REQUIRED.

    -e end_time           is in the same form as start_time. REQUIRED.

    -c channel_name       is the full channel name. Can be used multiple times
                          to specify multiple channels. This or -l is REQUIRED.

    -l channel_list       is a keyword specifying one of the following preset
                          lists of channels:

                          slow   -- slow channels

    -p output_directory   defaults to ~/. Timeseries text files will be saved
                          to output_directory/channel_name.

    -P                    do not start a new dump, but check the progress of
                          an ongoing dump with the given parameters.

    -h                    shows this message.

USAGE
}

# function for dumping channels (inspired by original geco_dump_channel)
# dump dump_start_time dump_end_time outdir channel_name
dump () {
    dump_start_time="${1}"
    dump_end_time="${2}"
    outdir="${3}"
    channel_name="${4}"
    # get data for each time
    current_time="${dump_start_time}"
    if ! [ -e "${outdir}" ]; then
        mkdir -p "${outdir}"
    fi
    # first letter of channel specifies observatory; needed by gw_data_find
    observatory_letter="$(echo ${channel_name} | head -c 1)"
    while [ "${current_time}" -lt "${dump_end_time}" ]; do
        # create a descriptive path name where this should be saved
    outpath="${outdir}/${current_time}".dat

        # skip the file if it already exists
        if ! [ -e "${outpath}" ]; then
            # get the file path for this time
            path=`gw_data_find -o ${observatory_letter} \
                               -t ${observatory_letter}1_R \
                               -s ${current_time} \
                               -e ${current_time} \
                               -u file \
                | sed 's/[^:^\/]*:\/\/[^\/]*//'`
            if [ "${path}" == "" ]; then
                echo No frame file found for ${current_time}, skipping...
            else
                echo Path: ${path}
                echo Dumping data to ${outpath}...
                framecpp_dump_channel --channel "${channel_name}" \
                                      "${path}" > "${outpath}"
            fi
        fi

        # move on to the next time
        let 'current_time+=64'
    done
}

# lists of timediff channels from channels.py file:
# slow_channels=`cat dev/data/channels.py | sed -n '2,13p' | sed -ne 's/.*'"'"'\(.*\)'"'"'$/\1/p'`
slow_channels=(
    "H1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "H1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_2"
    "H1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "H1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "L1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_1"
    "L1:SYS-TIMING_C_MA_A_PORT_2_SLAVE_CFC_TIMEDIFF_2"
    "L1:SYS-TIMING_X_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3"
    "L1:SYS-TIMING_Y_FO_A_PORT_9_SLAVE_CFC_TIMEDIFF_3")

# get options
outdir_pre=""
start_time=""
end_time=""
check_dump_progress=false
unset channel_names
while getopts ":p:s:e:c:l:Ph" opt; do
    case ${opt} in
        p)  outdir_pre="${OPTARG}";;
        s)  start_time="${OPTARG}";;
        e)  end_time="${OPTARG}";;
        c)  channel_names+=("${OPTARG}");;
        l)
            case "${OPTARG}" in
                slow) channel_names+=${slow_channels[*]};;
            esac
            ;;
        P)  check_dump_progress=true;;
        h)  usage && exit;;
        :)
            echo "Option -${OPTARG} requires an argument." >&2
            exit 1
            ;;
        \?)
            echo "Invalid option: -${OPTARG}" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

# there should be no non-flag arguments
if ! [ "$#" == 0 ]; then
    echo "Expected only flag arguments; got $# non-flag arguments." >&2
    usage
    exit 1
elif [ "${start_time}" == "" ]; then
    echo "Error: Must provide start time with -s flag." >&2
    usage
    exit 1
elif [ "${end_time}" == "" ]; then
    echo "Error: Must provide end time with -e flag." >&2
    usage
    exit 1
elif ! [ "${channel_names}" ]; then
    echo "Error: Must provide at least one channel name with -c flag." >&2
    usage
    exit 1
fi

gps_start_time=$(lalapps_tconvert ${start_time})
gps_end_time=$(lalapps_tconvert ${end_time})
if ${check_dump_progress}; then
    # total number of frame files to be processed in this time range
    num_frame_files=$(dc -e "${gps_end_time} 64/${gps_start_time} 64/-1+p")
    while true; do
        clear
        echo Start time: $(lalapps_tconvert -d ${start_time})
        echo End time: $(lalapps_tconvert -d ${end_time})
        echo GPS start time: ${gps_start_time}
        echo GPS end time: ${gps_end_time}
        echo Files to process: ${num_frame_files}
        echo NOTE: If data cannot be found, files will be skipped, causing
        echo progress to seemingly hang at around 100%.
        printf 'CURRENT TIME: '
        date
        printf 'SIZE MODIFIED         CHANNEL\n'
        for channel_name in ${channel_names[*]}; do
            dir="$(printf "${channel_name}" | tr ':' '_')"
            usg=$(du -h --time --max-depth=0 "${dir}")
            cnt=$(ls "${dir}" | wc -l)
            pct=$(dc -e "${cnt} 100*${num_frame_files}/p")
            echo ${usg} ${cnt}/${num_frame_files} \(${pct}\%\)
        done
        # sleep for 5 minutes before recomputing, or accept input
        read -n 1 -s -t 500 -p 'press [q] to quit or [r] to refresh.' cmnd
        case "${cmnd}" in
            q) echo && exit;;
            r) continue;;
        esac
    done
else
    # dump each channel
    dump_start_time=$(dc -e "${gps_start_time} 64/64*p")
    dump_end_time=$(dc -e "${gps_end_time} 64/64*64+p")
    # fork a process for each channel dump and print output to a log file
    for channel_name in ${channel_names[*]}; do
        # default output directory is ~/channel_name; else is outdir_pre/channel_name
        if [ "$outdir_pre" == "" ]; then
            outdir="$HOME/$(printf "${channel_name}" | tr ':' '_')"
        else
            outdir="${outdir_pre}/$(printf "${channel_name}" | tr ':' '_')"
        fi
        echo Forking for ${channel_name}
        logfile="$(printf "${channel_name}" | tr ':' '_').log"
        dump "${dump_start_time}" "${dump_end_time}" \
             "${outdir}" "${channel_name}" \
            >> "${logfile}" &
    done
fi
