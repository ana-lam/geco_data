#!/usr/bin/env python

# plot an IRIG-B signal read from stdin or from a textfile
# assumes that the input values each appear on a new line

# Force matplotlib to not use any Xwindows backend. NECESSARY ON CLUSTER.
import matplotlib
matplotlib.use('Agg')
import sys
import time
import argparse
import numpy as np
import matplotlib.pyplot as plt
import geco_irig_decode

# the number of subdivisions fo the final plot
num_subdivs = 5

# user can specify which detector this is and what to call the output file
parser = argparse.ArgumentParser()
parser.add_argument("--detector", help="the detector; used in the title of the output plot")
parser.add_argument("-O", "--outfile", help="the filename of the generated plot")
parser.add_argument("-T", "--timeseries", help="copy from stdin to stdout while reading",
                    action="store_true")
parser.add_argument("-A", "--actualtime", help="actual time signal was recorded (appears in title)")
args = parser.parse_args()

# get the detector name
if not (args.detector) or args.detector is None:
    detector_name = ""
else:
    detector_name = " at " + args.detector

# get the output filename
if not (args.outfile) or args.outfile is None:
    output_filename = "irigb-plot-made-at-" + str(time.time()) + ".png"
else:
    output_filename = args.outfile
    # append .png if not already there
    if output_filename.split(".")[-1] != "png":
        output_filename += ".png"

# get the actual time of recording, if provided
if not (args.actualtime) or args.outfile is None:
    actual_time_str = ""
else:
    actual_time_str = "\nActual Time: " + args.actualtime

# bitrate of signal (only decode one second)
bitrate = 16384

# initialize a numpy array with the data
timeseries = np.zeros(bitrate)

# read in data from stdin; don't read more than a second worth of data
# print("loading data")
line = ""
i = 0
while i < bitrate:
    line = float(sys.stdin.readline())
    timeseries[i] = line
    if args.timeseries:
        print(line)
    i += 1

# find max and min values in timeseries; use these to set plot boundaries
yrange = timeseries.max() - timeseries.min()
ymax = timeseries.max() + 0.1*yrange
ymin = timeseries.min() - 0.1*yrange

# the times within the interval
times = np.linspace(0, 1, num=bitrate, endpoint=False)

# print("making plot")
plt.close('all')
plt.figure(1, figsize=(7,10))
# plot the full second on the first row; lines should be black ('k' option).
plt.subplot(num_subdivs + 1, 1, 1)
plt.ylim(ymin, ymax)
plt.plot(times, timeseries, 'k')
# make num_subdivs subplots to better show the full second
for plot_num in range(0, num_subdivs):
    # print("making plot " + str(plot_num))
    plt.subplot(num_subdivs + 1, 1, plot_num+2)
    plt.ylim(ymin, ymax)
    plt.xlim(float(plot_num)/num_subdivs, (float(plot_num)+1)/num_subdivs)
    plt.plot(times[ bitrate * plot_num // num_subdivs : bitrate * (plot_num+1) // num_subdivs ],
             timeseries[ bitrate * plot_num // num_subdivs : bitrate * (plot_num+1) // num_subdivs ],
             'k')
# add title and so on
try:
    decoded_time = geco_irig_decode.get_date_from_timeseries(timeseries)
    decoded_time_str = decoded_time.strftime('%a %b %d %X %Y')
except ValueError as e:
    decoded_time_str = "COULD NOT DECODE TIME"
plt.suptitle("One Second of IRIG-B Signal" + detector_name + '\n'
             + "Decoded Time: " + decoded_time_str + actual_time_str)
plt.xlabel("Time since start of second [$s$]")
# plt.ylabel("IRIG-B Signal")
# print("saving plot")
plt.subplots_adjust(left=0.125, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.5)
plt.savefig(output_filename)
