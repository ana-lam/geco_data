#!/bin/bash

# a script for dumping to text a timeseries for a given channel
# over a given time range from the highest speed storage medium
# Stefan Countryman 4/2/2016

set -o errexit
set -o nounset
set -o noclobber
# print everything before executing
# set -o xtrace

usage() {
    cat <<USAGE
USAGE: geco_dump_channel -s start_time -e end_time -c channel_name [ OPTIONS... ]

OPTIONS:

    -s start_time         is in the form Sep 01 00:00:00 GMT 2015. REQUIRED.

    -e end_time           is in the same form as start_time. REQUIRED.

    -c channel_name       is the full channel name. REQUIRED.

    -p output_directory   defaults to ~/. Timeseries text files will be saved
                          to output_directory/channel_name.

    -h help               shows this message.

USAGE
}

# get options
outdir_pre=""
start_time=""
end_time=""
channel_name=""
while getopts ":p:s:e:c:h" opt; do
    case $opt in
        p)
            outdir_pre="$OPTARG"
            # echo "-p was triggered, parameter: $OPTARG" >&2
            ;;
        s)
            start_time="$OPTARG"
            # echo "-s was triggered, parameter: $OPTARG" >&2
            ;;
        e)
            end_time="$OPTARG"
            # echo "-e was triggered, parameter: $OPTARG" >&2
            ;;
        c)
            channel_name="$OPTARG"
            # echo "-c was triggered, parameter: $OPTARG" >&2
            ;;
        h)
            usage
            exit
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
        ?)
            echo "Invalid option: -$OPTARG" >&2
            usage
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

# there should be no non-flag arguments
if ! [ "$#" == 0 ]; then
    echo "Expected only flag arguments; got $# non-flag arguments." >&2
    usage
    exit 1
elif [ "$start_time" == "" ]; then
    echo "Error: Must provide start time with -s flag." >&2
    usage
    exit 1
elif [ "$end_time" == "" ]; then
    echo "Error: Must provide end time with -e flag." >&2
    usage
    exit 1
elif [ "$channel_name" == "" ]; then
    echo "Error: Must provide channel name with -c flag." >&2
    usage
    exit 1
fi

# first letter of channel specifies observatory; needed by gw_data_find
observatory_letter="$(echo $channel_name | head -c 1)"
# default output directory is ~/channel_name; else is outdir_pre/channel_name
if [ "$outdir_pre" == "" ]; then
    outdir="$HOME/$(printf "${channel_name}" | tr ':' '_')"
else
    outdir="${outdir_pre}/$(printf "${channel_name}" | tr ':' '_')"
fi

# translate times to gps
gps_start_time=`lalapps_tconvert "$start_time"`
echo GPS start time: $gps_start_time
gps_end_time=`lalapps_tconvert "$end_time"`
echo GPS end time: $gps_end_time

# find times
dump_start_time=`dc -e "$gps_start_time 64/64*p"`
echo Dump start time: $dump_start_time
dump_end_time=`dc -e "$gps_end_time 64/64*64+p"`
echo Dump end time: $dump_end_time

# get data for each time
current_time="$dump_start_time"
if ! [ -e "$outdir" ]; then
    mkdir -p "$outdir"
fi
while [ "$current_time" -lt "$dump_end_time" ]; do
    # create a descriptive path name where this should be saved
    outpath="$outdir/$current_time".dat

    # skip the file if it already exists
    if ! [ -e "$outpath" ]; then
        # get the file path for this time
        path=`gw_data_find -o $observatory_letter -t "$observatory_letter"1_R \
            -s $current_time -e $current_time -u file \
            | sed 's/[^:^\/]*:\/\/[^\/]*//'`
        if [ "$path" == "" ]; then
            echo No frame file found for $current_time, skipping...
        else
            echo Path: $path
            echo Dumping data to $outpath...
            framecpp_dump_channel --channel "$channel_name" "$path" > "$outpath"
        fi
    fi

    # move on to the next time
    let 'current_time+=64'
done
